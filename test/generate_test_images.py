#!/usr/bin/env python3
"""
Generate random test images and publish to EPICS PV using pvaPy.

Usage:
    python generate_test_images.py --pv TEST:image --fps 10 --width 512 --height 512
    python generate_test_images.py --pv TEST:image --fps 30 --pattern noise
    python generate_test_images.py --pv TEST:image --fps 5 --pattern gradient --moving
"""

import argparse
import time
import numpy as np
import pvaccess as pva


class AdImageUtility:
    """Utility class for manipulating Area Detector images."""

    NTNDA_DATA_FIELD_KEY_MAP = {
        np.dtype('uint8')   : 'ubyteValue',
        np.dtype('int8')    : 'byteValue',
        np.dtype('uint16')  : 'ushortValue',
        np.dtype('int16')   : 'shortValue',
        np.dtype('uint32')  : 'uintValue',
        np.dtype('int32')   : 'intValue',
        np.dtype('uint64')  : 'ulongValue',
        np.dtype('int64')   : 'longValue',
        np.dtype('float32') : 'floatValue',
        np.dtype('float64') : 'doubleValue'
    }

    PVA_DATA_TYPE_MAP = {
        np.dtype('uint8')   : pva.UBYTE,
        np.dtype('int8')    : pva.BYTE,
        np.dtype('uint16')  : pva.USHORT,
        np.dtype('int16')   : pva.SHORT,
        np.dtype('uint32')  : pva.UINT,
        np.dtype('int32')   : pva.INT,
        np.dtype('uint64')  : pva.ULONG,
        np.dtype('int64')   : pva.LONG,
        np.dtype('float32') : pva.FLOAT,
        np.dtype('float64') : pva.DOUBLE
    }

    @classmethod
    def generateNtNdArray2D(cls, imageId, imageData, nx=None, ny=None, dtype=None,
                           compressorName=None, extraFieldsPvObject=None):
        """Generate NTNDA for a mono image."""
        if extraFieldsPvObject is None:
            ntNdArray = pva.NtNdArray()
        else:
            ntNdArray = pva.NtNdArray(extraFieldsPvObject.getStructureDict())

        dataFieldKey = cls.NTNDA_DATA_FIELD_KEY_MAP.get(imageData.dtype)
        data = imageData.flatten()

        if not compressorName:
            pvaDataType = cls.PVA_DATA_TYPE_MAP.get(imageData.dtype)
            ny, nx = imageData.shape
            size = nx * ny * data.itemsize
            ntNdArray['compressedSize'] = size
            ntNdArray['uncompressedSize'] = size
        else:
            dtype = np.dtype(dtype)
            pvaDataType = cls.PVA_DATA_TYPE_MAP.get(dtype)
            codec = pva.PvCodec(compressorName, pva.PvInt(int(pvaDataType)))
            ntNdArray['codec'] = codec
            size = nx * ny * dtype.itemsize
            ntNdArray['uncompressedSize'] = size
            ntNdArray['compressedSize'] = len(data)

        ntNdArray['uniqueId'] = int(imageId)
        dims = [pva.PvDimension(nx, 0, nx, 1, False),
                pva.PvDimension(ny, 0, ny, 1, False)]
        ntNdArray['dimension'] = dims
        ts = pva.PvTimeStamp(time.time())
        ntNdArray['timeStamp'] = ts
        ntNdArray['dataTimeStamp'] = ts
        ntNdArray['descriptor'] = 'Image generated by PvaPy'

        ntNdArray['value'] = {dataFieldKey: data}
        attrs = [pva.NtAttribute('ColorMode', pva.PvInt(0))]
        ntNdArray['attribute'] = attrs

        if extraFieldsPvObject is not None:
            ntNdArray.set(extraFieldsPvObject)

        return ntNdArray

    @classmethod
    def replaceNtNdArrayImage2D(cls, ntNdArray, imageId, image, extraFieldsPvObject=None):
        """
        Replace image data in an existing NTNDArray.
        Assumes new image is of the same data type as the old one.
        """
        dataFieldKey = cls.NTNDA_DATA_FIELD_KEY_MAP.get(image.dtype)
        pvaDataType = cls.PVA_DATA_TYPE_MAP.get(image.dtype)
        data = image.flatten()
        ntNdArray['uniqueId'] = int(imageId)

        ny, nx = image.shape
        dims = ntNdArray['dimension']

        if dims[0]['size'] != nx or dims[1]['size'] != ny:
            dims = [pva.PvDimension(nx, 0, nx, 1, False),
                    pva.PvDimension(ny, 0, ny, 1, False)]
            ntNdArray['dimension'] = dims
            size = nx * ny * data.itemsize
            ntNdArray['compressedSize'] = size
            ntNdArray['uncompressedSize'] = size

        ts = pva.PvTimeStamp(time.time())
        ntNdArray['timeStamp'] = ts
        ntNdArray['dataTimeStamp'] = ts

        u = pva.PvObject({dataFieldKey: [pvaDataType]}, {dataFieldKey: data})
        ntNdArray.setUnion(u)

        if extraFieldsPvObject is not None:
            ntNdArray.set(extraFieldsPvObject)

        return ntNdArray


class ImageGenerator:
    """Generate test images with various patterns."""

    def __init__(self, width=512, height=512, pattern='noise', dtype=np.uint16):
        self.width = width
        self.height = height
        self.pattern = pattern
        self.dtype = dtype
        self.frame_counter = 0
        self.t0 = time.time()

    def generate(self):
        """Generate a single frame based on pattern type."""
        if self.pattern == 'noise':
            return self._noise_pattern()
        elif self.pattern == 'gradient':
            return self._gradient_pattern()
        elif self.pattern == 'circles':
            return self._circles_pattern()
        elif self.pattern == 'moving_dot':
            return self._moving_dot_pattern()
        elif self.pattern == 'sine_wave':
            return self._sine_wave_pattern()
        else:
            return self._noise_pattern()

    def _noise_pattern(self):
        """Random noise."""
        if self.dtype == np.uint16:
            return np.random.randint(0, 65536, (self.height, self.width), dtype=np.uint16)
        else:
            return np.random.randint(0, 256, (self.height, self.width), dtype=np.uint8)

    def _gradient_pattern(self):
        """Horizontal gradient with optional motion."""
        x = np.linspace(0, 1, self.width)
        y = np.ones(self.height)
        gradient = np.outer(y, x)

        # Add some temporal variation
        phase = self.frame_counter * 0.1
        gradient = (gradient + 0.3 * np.sin(phase)) / 1.3

        if self.dtype == np.uint16:
            return (gradient * 65535).astype(np.uint16)
        else:
            return (gradient * 255).astype(np.uint8)

    def _circles_pattern(self):
        """Concentric circles."""
        y, x = np.ogrid[:self.height, :self.width]
        cx, cy = self.width // 2, self.height // 2
        r = np.sqrt((x - cx)**2 + (y - cy)**2)

        # Animate circles
        phase = self.frame_counter * 0.2
        pattern = np.sin(r / 20 - phase)
        pattern = (pattern + 1) / 2  # Normalize to [0, 1]

        if self.dtype == np.uint16:
            return (pattern * 65535).astype(np.uint16)
        else:
            return (pattern * 255).astype(np.uint8)

    def _moving_dot_pattern(self):
        """Single dot moving in a circle."""
        img = np.zeros((self.height, self.width), dtype=self.dtype)

        # Circular motion
        t = self.frame_counter * 0.1
        cx = self.width // 2 + int(self.width // 4 * np.cos(t))
        cy = self.height // 2 + int(self.height // 4 * np.sin(t))

        # Draw dot
        y, x = np.ogrid[:self.height, :self.width]
        r = np.sqrt((x - cx)**2 + (y - cy)**2)
        mask = r < 20

        if self.dtype == np.uint16:
            img[mask] = 65535
        else:
            img[mask] = 255

        return img

    def _sine_wave_pattern(self):
        """Animated sine wave pattern."""
        y, x = np.ogrid[:self.height, :self.width]

        # Create sine wave
        phase = self.frame_counter * 0.2
        pattern = np.sin(x / 30 + phase) * np.sin(y / 30 + phase * 0.7)
        pattern = (pattern + 1) / 2  # Normalize to [0, 1]

        if self.dtype == np.uint16:
            return (pattern * 65535).astype(np.uint16)
        else:
            return (pattern * 255).astype(np.uint8)




def main():
    parser = argparse.ArgumentParser(description='Generate test images for EPICS PVAccess')
    parser.add_argument('--pv', type=str, default='TEST:image',
                        help='PV name to publish to (default: TEST:image)')
    parser.add_argument('--fps', type=float, default=10.0,
                        help='Frames per second (default: 10)')
    parser.add_argument('--width', type=int, default=512,
                        help='Image width (default: 512)')
    parser.add_argument('--height', type=int, default=512,
                        help='Image height (default: 512)')
    parser.add_argument('--pattern', type=str, default='noise',
                        choices=['noise', 'gradient', 'circles', 'moving_dot', 'sine_wave'],
                        help='Pattern type (default: noise)')
    parser.add_argument('--dtype', type=str, default='uint16',
                        choices=['uint8', 'uint16'],
                        help='Data type (default: uint16)')
    parser.add_argument('--duration', type=float, default=None,
                        help='Duration in seconds (default: run forever)')

    args = parser.parse_args()

    # Convert dtype string to numpy dtype
    dtype = np.uint16 if args.dtype == 'uint16' else np.uint8

    # Create image generator
    generator = ImageGenerator(args.width, args.height, args.pattern, dtype)

    # Create PVAccess server channel
    print(f"Publishing to PV: {args.pv}")
    print(f"Pattern: {args.pattern}")
    print(f"Resolution: {args.width}x{args.height}")
    print(f"FPS: {args.fps}")
    print(f"Data type: {args.dtype}")
    print("Press Ctrl+C to stop\n")

    try:
        # Initialize PVA server with dummy NTNDArray
        dummy = np.zeros((args.height, args.width), dtype=dtype)
        nt = AdImageUtility.generateNtNdArray2D(0, dummy)
        server = pva.PvaServer()
        server.addRecord(args.pv, nt)

        # Calculate frame interval
        frame_interval = 1.0 / args.fps
        start_time = time.time()
        uid = 0

        while True:
            # Generate image
            image = generator.generate()
            generator.frame_counter += 1
            uid += 1

            # Update NTNDArray with new image
            AdImageUtility.replaceNtNdArrayImage2D(nt, uid, image)
            server.update(nt)

            # Print status
            elapsed = time.time() - start_time
            actual_fps = uid / elapsed if elapsed > 0 else 0
            print(f"\rFrame {uid:6d} | "
                  f"Elapsed: {elapsed:6.1f}s | "
                  f"Actual FPS: {actual_fps:5.1f} | "
                  f"Target: {args.fps:5.1f}",
                  end='', flush=True)

            # Check duration limit
            if args.duration is not None and elapsed >= args.duration:
                print(f"\n\nReached duration limit of {args.duration} seconds")
                break

            # Sleep to maintain frame rate
            next_frame_time = start_time + uid * frame_interval
            sleep_time = next_frame_time - time.time()
            if sleep_time > 0:
                time.sleep(sleep_time)

    except KeyboardInterrupt:
        print("\n\nStopped by user")
    except Exception as e:
        print(f"\n\nError: {e}")
        import traceback
        traceback.print_exc()


if __name__ == '__main__':
    main()
